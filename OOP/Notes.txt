Encapsulation:
Hiding/abstracting away the implementation details
and just leaving a public interface for programmers to use
i.e. member variables are private and only set via public functions
this allows error checking (e.g. bounds checking)

Destructor:
called before a object is earsed from memory, useful
to do some cleanup, i.e. delete dynamic memory or close a file
std::exit() bypasses all destructors

Resource Acquisition Is Initialization:
all resoruces are created at the start of or during the lifetime of an object
they are then cleaned up at the end of the object's lifetime

Converting Constructor:
explicit keyword makes a constructor not able to do implicit converstion
to create an object from a non object value i.e. printCar("BMW", "EXEMPT", 2024)
would NORMALLY just create a Car object with those parameters BUT if explicit is
used then such a converstion does NOT happen.
the delete keyword can be used to delete a function, such as deleting a constructor
that takes in bogus input (which would populate the class with nonsense), as a way of
nulling such calls.

Composition:
Making a complex object from multilple simpler objects
(structs and classes) == composite type
"death relationship" the whole manages the lifetime of the part
unidirectional relationship, the part does not know it is part of the whole
"has-a" or "part-of" relationship

Aggregation:
part-whole relationship
parts are NOT managed by the whole
parts CAN belong to other wholes (other classes)
this is done with classes that use pointers or refreneces instead of direct values
e.g. pointer to a string instead of a string, that way when the object is destroyed/
goes out of scope, the string still exists

Association:
uses-a relationship
part is unrelated to the whole
part can belong to many wholes
part is NOT managed by the whole
part may or may not know of the whole
a reflexive association is when a object has a relationship with another
object of the same type, i.e. Car has a Car* pointer
or indirectly via a lookup table with ids

Dependency:
when a object needs the functionality of another object to accomplish a task

Container Class:
A class desgined to hold other classes or data i.e. std::array, std::vector
elements of the container hold a "member-of" relationship to the container class
Value container = composition (i.e. responsbile for creation and destruction)
Reference container = aggregation (i.e. not responsible for create/destroy)

Inhertitance:
Acquiring properties from another object
Higharchies shows a top-bottom relationship between objects
"is-a" relationship
parent class == base class == superclass (class BEING inherited from)
child class == derived class == subclass (class doing the inheriting)

Protected and access specifiers:
proteced --> members, firends, and derived classes i.e. a friednler private
public inhertitance --> public stays public, private stayes private, protected stays proteced
protected inhertitance --> public becomes proteced, proteced stays proteced, private stays private
private inhertitance --> everything becomes private from the OUTSIDE, i.e. inside the class public and proteced
members from the base class ARE still accessible

Multiple inhertitance:
    class Derived : public Base1, public Base2
make sure the constrcuor can feed Base1() and Base2()