// casting
static_cast<int>('A')

// avoid getline(cin >> ws, var)
// by using cout << endl;
// to flush the buffer (therefore no longer leaving a \n in the buffer for cin) 

// Loop through array syntax
my_array[3] = {"Hello", "There", "!"}
for (int i : my_array)
{
    cout << i;
}

// Pointer to pointer
// new returns a pointer
// new on a pointer type would return a pointer to a pointer
int** ptr { new int*[10] }

// both refrences and pointers allow changing a variable passed
int someFunction(int &x)
int someFunction(int* x)

// auto dedcues type for obvious declarations
auto x = 5; // x is set to int AUTOmatically

// command line arguments, it is C-style
int main(int argc, char** argv)

// in C++
// STRUCT = CLASS

// struct with pointer
myStruct* ptr {&myStructInstance};
(*ptr).name // will access the name member of the derefrenced pointer
            // need to use () in order to make dereferncing take place over the dot operator (PEMDAS)
ptr->name   // will dereference and select the name member from the ptr
*ptr->name  // WRONG: -> already derefernces so do NOT also use *


// store refrences in a vector
// via the std::reference_wrapper<> function
// to access the object must use the .get() method on the
// vector index
vector<reference_wrapper<TYPE>> vector_name {member1, member2, member3};
vector_name[i].get().objectMethod()

// TODO:
operator overloading
covarient return types
recursion <-- Seriously